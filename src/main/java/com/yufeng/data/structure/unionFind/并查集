高级树结构 ———— 并查集(Union Find)    外文名: union-find disjoint sets


并查集
   1. 可以高效的解决连接问题(Connectivity Problem);
   2. 可以非常快的判断网络中节点间的连接状态;
      网络是个抽象的概念: 用户之间形成的网络, 是个应用非常广泛的概念
   3. 数学中的集合类实现
   4. 连接问题和路径问题   比路径问题要回答的问题少
   5. 对于一组数据, 主要支持两个动作
      5.1 union(p, q)
      5.2 isConnected(p, q)

========================================

并查集 ———— 定义:
   1. 在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，
      其间要反复查找一个元素在哪个集合中;
   2. 这一类问题近几年来反复出现在信息学的国际国内赛题中。其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，
      往往在空间上过大，计算机无法承受;
   3. 即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述;
   4. 并查集是一种树型的数据结构，用于处理一些不相交集合（disjoint sets）的合并及查询问题。常常在使用中以森林来表示;

   5. 并查集主要用于解决一些元素分组的问题。它管理一系列不相交的集合，并支持两种操作:
      合并（Union）：把两个不相交的集合合并为一个集合;
      查询（Find）：查询两个元素是否在同一个集合中;

   6. 并查集最直接的一个应用场景: 亲戚问题;

========================================

亲戚问题 ———— 题目背景
   若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。
   题目描述
        规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。
   输入格式
        第一行：三个整数n,m,p，（n<=5000,m<=5000,p<=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。
        以下m行：每行两个数Mi，Mj，1<=Mi，Mj<=N，表示Mi和Mj具有亲戚关系。
        接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。
   输出格式
        P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。


这其实是一个很有现实意义的问题。我们可以建立模型，把所有人划分到若干个不相交的集合中，每个集合里的人彼此是亲戚。
为了判断两个人是否为亲戚，只需看它们是否属于同一个集合即可。因此，这里就可以考虑用并查集进行维护了

========================================

并查集的引入: 并查集的重要思想在于，用集合中的一个元素代表集合;

我曾看过一个有趣的比喻，把集合比喻成帮派，而代表元素则是帮主。接下来我们利用这个比喻，看看并查集是如何运作的;
   1. 最开始，所有大侠各自为战。他们各自的帮主自然就是自己。（对于只有一个元素的集合，代表元素自然是唯一的那个元素）;
   2. 现在1号和3号比武，假设1号赢了，那么3号就认1号作帮主（合并1号和3号所在的集合，1号为代表元素）;
   3. 现在2号想和3号比武（合并3号和2号所在的集合），但3号表示，别跟我打，让我帮主来收拾你（合并代表元素）。
      不妨设这次又是1号赢了，那么2号也认1号做帮主。
   4. 现在我们假设4、5、6号也进行了一番帮派合并，江湖局势变成下面这样;
   5. 现在假设2号想与6号比，跟刚刚说的一样，喊帮主1号和4号出来打一架（帮主真辛苦啊）。1号胜利后，4号认1号为帮主，当然他的手下也都是跟着投降了

好了，比喻结束了。如果你有一点图论基础，相信你已经觉察到，这是一个树状的结构，要寻找集合的代表元素，
只需要一层一层往上访问父节点（图中箭头所指的圆），直达树的根节点（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树;

图片详见: unionFind/images/faction/

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————





————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Quick Find
   1. unionElements(p, q) ————> O(n);
   2. isConnected(p, q)   ————> O(1);


Quick Union 设计思路
   1. 将每一个元素, 看做是一个节点;
   2. 将合并与查询两个操作, 都是 O(h) 的时间复杂度;
   3. 树结构，也叫做森林结构;

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

基于rank的优化:
   1. rank[i]表示根节点为i的树的高度
   2. 之前基于size的优化, 可能会出现树的高度增加的情况(图片需下载)
   3. 从实现逻辑来看, 基于rank的优化是比基于size的优化更合理, 所以一般使用基于rand优化的并查集;


并查集一个非常重要的优化方式: 路径压缩(Path Compression)
   1. 让一颗比较高的树压缩成一颗比较矮的树;
   2. 设计: 路径压缩发生在什么时候? find操作, 顺便进行路径压缩!
      parent[p] = parent[parent[p]]
   3. 图片需下载!


并查集的时间复杂度分析
   1. O(h)
   2. 严格意义上: O(log * N)  ————> iterated logarithm
      近乎是O(1)级别的, 比logN还要快!

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


