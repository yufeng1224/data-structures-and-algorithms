树结构 ———— 二分搜索树(binary Search Tree)


为什么要有树结构?
   1. 树结构本身是一种天然的组织结构: 比如文件存储结构、 学校图书馆、 公司组织架构;
   2. 将数据使用数结构存储后，出奇的高效;
   3. 分类: 二分搜索树(Binary Search Tree), 平衡二叉树: AVL; 红黑树; 堆; 并查集;
      线段树; Trie(字典树, 前缀树)


树结构基础 ———— 二叉树
   1. 和链表一样, 是动态数据结构;
      class Node {
         E e;
         Node left;         // 左子树
         Node right;        // 右子树
      }
   2. 二叉树具有唯一根结点;
   3. 二叉树是每个结点最多有两个子树, 被称为左子树和右子树;
   4. 二叉树每个结点最多有一个父亲结点, 没有子树的称为叶子结点;
   5. 二叉树具有天然递归结构;
      5-1 每个节点的左子树也是二叉树;
      5-2 每个节点的右子树也是二叉树;
   6. 二叉树不一定是"满"的  (一个节点也可以是二叉树, 空也可以是二叉树);

小结:  二叉树是一个动态的数据结构，它具有唯一根结点，每个节点最多有左子树和右子树两个子结点。 二叉树具有天然的递归结构。


二分搜索树(二叉查找树) ———— Binary Search Tree
   1. 二分搜索树是二叉树，二分搜索树也称为二叉查找树;
   2. 二分搜索树的每个节点的值: 大于其左子树的所有结点的值, 小于其右子树的所有节点的值;
   3. 每一颗子树也是二分搜索树;
   4. 存储的元素必须有可比较性(如果存储student，需要自定义好student是如何比较的)
   5. 二分搜索树可以大大提高查询速度!!!

   6. 视频中二分搜索树不包含重复元素, 如果想包含重复元素的话，只需要定义: 左子树小于等于节点; 或者右子树大于等于节点。
      是否有重复元素，要看具体的应用而定!
      (之前将的数组和链表，可以有重复元素)
   7. 递归的写法本身是具有很高的开销! 二分搜索树一些方法的非递归实现，留作练习!
   8. 在二分搜索树方面, 递归比非递归实现简单(重点);


相关术语
   1. 结点: 包含一个数据元素及若干指向子树分支的信息;
   2. 结点的度: 一个结点拥有子树的数目称为结点的度;
   3. 叶子结点: 也称为终端结点, 没有子树的结点或者度为零的结点;
   4. 分支结点: 也称为非终端结点, 度不为零的结点称为非终端结点;
   5. 树的度: 树中所有结点的度的最大值;

   6. 结点的层次：从根结点开始，假设根结点为第1层，根结点的子节点为第2层，依此类推，如果某一个结点位于第L层，
      则其子节点位于第L+1层
   7. 树的深度：也称为树的高度，树中所有结点的层次最大值称为树的深度;
   8. 有序树：如果树中各棵子树的次序是有先后次序，则称该树为有序树;
   9. 无序树：如果树中各棵子树的次序没有先后次序，则称该树为无序树;
   10. 森林：由m（m≥0）棵互不相交的树构成一片森林。如果把一棵非空的树的根结点删除，则该树就变成了一片森林，
       森林中的树由原来根结点的各棵子树构成;


二叉树性质:
   性质1：二叉树的第i层上至多有2^(i-1)（i≥1）个节点;
   性质2：深度为h的二叉树中至多含有2^h - 1个节点;
   性质3：若在任意一棵二叉树中，有n0个叶子节点，有n2个度为2的节点，则必有n0 = n2+1;
   性质4：具有n个节点的完全二叉树深为log2x+1（其中x表示不大于n的最大整数）

   性质5：若对一棵有n个节点的完全二叉树进行顺序编号（1≤i≤n），那么，对于编号为i（i≥1）的节点
      1. 当i=1时，该节点为根，它无双亲节点;
      2. 当i>1时，该节点的双亲节点的编号为i/2;
      3. 若2i≤n，则有编号为2i的左节点，否则没有左节点;
      4. 若2i+1≤n，则有编号为2i+1的右节点，否则没有右节点

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

二分搜索树添加元素
   1. 当插入的元素e 跟当前的 node.e 相等, 不做处理, 直接返回 (递归终止条件一)
   2. 当插入的元素e 比当前 node.e 小, 并且当前结点的左子树没有值(node.left == null),
      将待插入的元素放入当前结点的 left, node.left = e;   (递归终止条件二)

   3. 当插入的元素e 比当前 node.e 大, 并且当前结点的右子树没有值(node.right == null),
      将待插入的元素放入当前结点的 right, node.right = e;   (递归终止条件三)

   4. 如果插入的元素e比当前node.e小, 并且当前结点有左子树, 需要将待插入的元素e进一步去和
      当前结点的左子树中的元素去比较 (使用递归)

   5. 如果插入的元素e比当前node.e大, 并且当前结点有右子树, 需要将待插入的元素e进一步去和
      当前结点的右子树中的元素去比较 (使用递归)


什么是遍历操作?
   1. 遍历操作就是把所有节点都访问一遍;
   2. 访问的原因和业务相关;
   3. 在线性结构下, 遍历是及其容易的;



二分搜搜树的前序遍历 ———— 对于遍历操作, 两颗子树都要顾及
   1. 示例代码
      function traverse(node)
       if (node == null)
            return;
       System.out.println("当前节点")
       traverse(node.left);
       traverse(node.right);

   2. 前序遍历是最自然的遍历方式, 最常用的遍历方式;
   3. 二分搜索树前序遍历: 先输出当前节点， 然后在输出左叶子节点，最后输出右叶子节点;



二分搜索树的中序遍历
   1. 示例代码
      function traverse(node)
       if (node == null)
   		  return;

       traverse(node.left);
       System.out.println("当前节点")			// 访问该节点放在了中间, 中序遍历是二分搜索树排序的结果
       traverse(node.right);

   2. 二分搜索树的中序遍历结果是顺序的。
   3. 中序遍历：对于二分搜索树，中序遍历的操作顺序（或输出结果顺序）是符合从小到大（或从大到小）顺序的，
      因此遍历输出排序好的结果需要使用中序遍历


二分搜索树的后序遍历
   1. 示例代码
      function traverse(node)
       if (node == null)
   		  return;

       traverse(node.left);
       traverse(node.right);
       // 访问该节点
   2. 后序遍历的一个应用: 为二分搜索树释放内存。
   3. 后序遍历: 先输出左子节点, 右子节点, 再输出父节点。

代码示例详见: BSTTest.java


二分搜索树的遍历 ———— 示例代码
   function traverse(node)
      if (node == null) return;

   1. 当前位置访问该节点? (这里就是前序遍历)
   traverse(node.left)
   2. 当前位置访问该节点? (这里就是中序遍历)
   traverse(node.right)
   3. 当前位置访问该节点? (这里就是后序遍历)


二分搜索树遍历的非递归实现
   1. 二分搜索树遍历的非递归实现, 比递归实现复杂得多;
   2. 中序遍历和后序遍历的非递归实现更复杂;
   3. 中序遍历和后序遍历的非递归实现, 实际应用不广;
   4. 中序遍历和后序遍历的非递归实现留做练习;
   5. 二分搜索树遍历的非递归实现都有经典教科书的写法!!!
      《玩转算法面试》 中完全模拟系统栈的写法


二分搜索树的前序遍历非递归实现
   1. 使用到了栈这种辅助数据结构来完成;
   2. 又称为深度优先遍历;
   3. 示例代码: BST.preOrderNR


二分搜索树的层序遍历
   1. 使用到了队列这种辅助数据结构来完成;
   2. 又称为广度优先遍历;
   3. 示例代码: BST.levelOrder

重点: 前序遍历和层序遍历需要去找图片来加深记忆!


广度优先遍历的意义:
   1. 更快的找到问题的解;
   2. 常用于算法设计中 ———— 最短路径
   3. 图中的深度优先遍历和广度优先遍历

学习知识不是简单的一块一块的学过就好了。 很多时候, 要想达到灵活运用, 能够达到理解的深刻, 都需要这样进行比对, 刻意地去找到不同方法之间的区别和联系。
以及自己去总结不同的方法适用于什么样的场合。 只有这样，这些知识在你的脑海中才不是一个一个的碎片! 而是有机地联系起来!

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

删除二分搜索树的最小元素和最大元素
   1. 寻找二分搜索树中的最小元素
      1-1 用递归方式实现, 示例代码: BST.minimum()
      1-2 尝试用非递归方式实现(练习题)

   2. 寻找二分搜索树中的最大元素
      2-1 用递归方式实现, 示例代码: BST.maximum()
      2-2 尝试用非递归方式实现(练习题)

   3. 删除二分搜索树的最小值



二分搜索树删除节点 ———— 条件归类
   1. 删除只有左孩子的节点
      删除当前节点之后, 将左孩子的节点连接在当前节点;

   2. 删除只有右子树的节点
      将当前节点的右子树覆盖到当前节点;

   3. 对叶子节点的处理比较简单(类似删除最大元素或者最小元素)

   4. Hibbard Deletion ———— 删除左右都有孩子的节点 d

      4-1 找到d后面右子树最小的节点(后继);  s = min(d -> right)
          s -> right = delMin(d -> right)
          s -> left  = d -> left
          删除 d, s是新的子树的根

      4-2 找到d后面左子树最大的节点(前驱);  s = max(d -> left)
          p = max(d -> left)

   5. 使用前驱来覆盖当前节点(练习用!)


二分搜索树的特性(其它练习!!):
    1. 二分搜索树的顺序性, 可以得到 successor,  predecessor
    2. 寻找45的 floor 和 ceil, floor: 比45 小的那个最大的数, 比45大的那个最小的数。
    3. rank: 58 是排名是第几的元素; select: 排名第10的元素是谁?
    4. 维护 depth 的二分搜索树
    5. 支持重复元素的二分搜索树


总结:
   1. 二分搜索树是后续学习其他树的基础: 比如平衡二叉树;
   2. 二分搜索树具有非常重要的性质: 顺序性; 可以得到 successor, predecessor
   3. 二分搜索树的两个应用: 集合和映射;
   4. 其他应用: 寻找45的 floor 和 ceil; (这个要去好好理解), 这个元素可以不在二分搜索树中
      比45小的那个最大的数, 比45大的那个最小的数。 (一个小的练习)

   5. 二分搜索树的rank和select
      rank: 58 是排名是第几的元素;  select: 排名第10的元素是谁?

   6. 维护 depth 的二分搜索树 (深度值, 也叫做高度值)
   7. 支持重复元素的二分搜索树
      (新增一个维护字段 count)
   8. 中序遍历和后序遍历的非递归都有教科书的写法, 需要掌握!


————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

树的遍历方式总体分为两类:
    1. 深度优先遍历(DFS)
    2. 广度优先遍历(BFS);


常见的DFS:
   1. 前序遍历;
   2. 中序遍历;
   3. 后序遍历;


常见的BFS
   1. 层序遍历(即按层遍历)



二分搜索树的深度
   1. 树的深度与它的左子树和右子树的深度存在直接的关系;
   2. 很明显的: 树的深度等于左子树的深度与右子树的深度中大的那个值再加1;


二分搜索树的深度 ————通过递归实现(深度优先遍历)
    1. 终止条件: 当前node为空时, 说明已经遍历到最深的地方, 因此返回深度0;
    2. 如果当前node还存在叶子节点, 则继续遍历当前节点的左子树或者右子树的深度;
    3. 所以, 对于当前节点来说, 它的深度 = Math.max(它的左子树的深度, 它的右子树的深度),取最大值再 + 1;
    4. 脑海中要有递归函层层调用的概念图; 函数递归遍历到底部再一层层返回
    5. 时间复杂度O(N): N为树的节点数量, 计算树的深度需要遍历所有节点!
    6. 空间复杂度O(N): 最差情况下(当树退化为链表时), 递归深度可达到N

小结: 要深刻理解二分搜索树的深度的解题条件, 也就是深度 = 取它的 左子树的深度 与 右子树的深度中大的那一个值 再 + 1;



二分搜索树的深度 ————通过队列实现(广度优先遍历)
   1. 如果 root 为空, 直接返回0;
   2. 设置一个变量 level， 用于统计层数(也就是深度)
   3. 使用辅助数据结构 队列, level ++, 然后将上一层的元素依次出队(从队首获得), 将出队的元素的子结点入队(放入队尾);
      (也就是将下一层的结点依次放入队尾);
   4. 直到队列为空了, 说明已经遍历到最后一层了, 返回层数level (也就是树的深度)!


————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

总结
   1. 二分搜索树也称为二叉排序树或者二叉搜索树;
   2. 它有以下这3个性质:
      2-1 如果根节点的左子树不为空，则左子树上所有节点的值都小于它的根节点;
      2-2 如果根节点的右子树不为空，则右子树上所有的节点的值都大于它的根节点;
      2-3 任意节点的左、右子树也分别为二分搜索树, 也就是说二分搜索树具有天然的递归结构;

   3. 然后对于二分搜索树的遍历, 可以分为 DFS——深度优先遍历 和 BFS——广度优先遍历;
   4. 常见的深度优先遍历有前序遍历、中序遍历和后序遍历, 二分搜索树可以直接通过递归来实现以上3种遍历方式;
      常见的广度优先遍历就是层序遍历, 二分搜索树的层序遍历需要借助队列来实现;

   5. 通过递归实现的前度遍历、中序遍历、后续遍历, 如果有 n 个节点, 则需要调用递归函数 2n+1次!
      (所有的递归函数不会一直存在于方法栈中, 如果左子树的节点遍历完成，递归方法会出栈，所以不太可能会出现栈溢出的情况)

   6.
————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————



































