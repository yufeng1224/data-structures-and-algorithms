线性数据结构 ———— 链表(linkedList)


链表(数据结构学习的重点)
   1. 动态数组、栈、队列, 底层是依托静态数组, 靠 resize 解决固定容量问题;
   2. 链表是真正的动态数据结构;
   3. 最简单的动态数据结构; (它是二分搜索树、trie、 平衡二叉树的基础)
   4. 涉及到计算机领域非常重要的一个概念: 引用(或者指针);
   5. 更深入的理解递归(非常重要);
   6. 辅助组成其他数组结构;


链表相关概念:
   1. 数据存储在 "节点"(Node)中;
   2. class Node {
         E e;
         Node next;
      }
   3. 规则: 如果一个节点的 node.next=null, 说明它肯定是最后一个节点了;
   4. 优点: 真正的动态，不需要处理固定容量的问题; (整体是动态的，不会大量的浪费内存空间)
   5. 缺点: 丧失了随机访问的能力;


数组和链表的对比
   1. 数组最好用于索引有语意的情况。 scores[2] (最大的优点: 支持快速查询)
   2. 链表不适合用于索引有语意的情况。(最大的优点: 动态)

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

在链表中间添加元素
   1. 关键: 找到要添加的节点的前一个节点;
   2. 正确示例代码:
        node.next = prev.next;
        prev.next = node;
      这两句代码的执行顺序必须是这样! (顺序很重要! 颠倒顺序会导致错误!)

   3. 错误示例代码:
        prev.next = node;
        node.next = prev.next;

   4. 为链表设立虚拟头节点, 可以优化代码。 (用于编写逻辑方便!)
      就像之前的循环数组队列一样, 我们有意识的浪费了一个空间


链表的时间复杂度分析
   1. 添加操作 -- O(n)
      1-1 addLast(e)           O(n);
      1-2 addFirst(e)          O(1);
      1-3 add(index, e)        O(n);

   2. 删除操作 -- O(n)
      2-1 removeLast(e)        O(n);
      2-2 removeFirst(e)       O(1);
      2-3 remove(index, e)     O(n);

   3. 修改操作
      3-1 set(index, e)        O(n);

   4. 查找操作
      4-1 get(index)           O(n);
      4-2 contains(e)          O(n);

总结:  增删改查都是 O(n)，  如果只对链表头进行操作 -- O(1);  (所以通过链表来实现栈非常有优势!)

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

递归:
   1. 本质上, 将原来的问题，转换为更小的同一问题;
   2. 举例: 数组求和
      Sun(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1]), 更小的同一问题;
      Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1]), 更小的同一问题;
      Sum(arr[n-1...n-1]) = arr[n-1] + Sum([]);  最基本的问题;
   3. 详见 RecursiveSum.java 示例


递归顺序:  所有递归函数都可以分为两部分!!!
   1. 求解最基本问题;
   2. 把原问题转换成更小的问题(这里涉及到自己调用自己, 核心部分);
   3. 自己感悟: 递归一定会从左向右、 从上到下， 一直到最后一层，然后再一次一层层返回。(递归流程需要好好掌握)
   4. 详见 leetCode-203。 这道题目很经典，一定要好好理解
   5. 递归算法的调试: linkedList.Solution.java


更多和链表相关的话题:
   1. 链表天然的递归性: 0 -> 1 -> 2 -> 3 -> NULL  可以变成 0 -> 一个更短的链表(少了一个节点)
   2. 递归运行的机制: 递归的微观解读 5-5 视频， 如果以后忘记原理了，可以好好再回顾下。
   3. 递归调用是有代价的: 函数调用 + 系统栈空间。 (深递归导致栈内存溢出)
   4. 近乎和链表相关的所有操作, 都可以使用递归的形式实现。 (建议同学们对链表的增、删、改、查进行递归实现)
   5. 斯坦福大学 链表文档 ---- 全部编写一遍将会进一步提升自己的水平。
   6. 双向链表, 循环链表(java 中链表类 LinkedList 是循环双向链表, 每个节点是有两个指针的)

2019-08-16 感悟: 递归不明白一定要用纸笔写一写!!!  就跟数学题一样，要多加练习，以后就会越做越快的。


双链表
   Node head, tail;
   class Node {
        E e;
        Node next, prev;
   }

循环链表

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

时间复杂度分析
   1. 添加操作:  addLast()       O(n);   addFirst()     O(1);  add(index, e)     O(n/2) -> O(n);   整体来看是O(n)级别的操作;
   2. 删除操作:  removeLast()    O(n);   removeFirst()  O(1);  remove(index, e)  O(n/2) -> O(n);   整体来看是O(n)级别的操作
   3. 修改操作:  set(index, e);  O(n) 级别的操作;
   4. 查找操作:  get(index)      O(n);   contains(e)    O(n);
   5. 增、删操作是优点!
   总结: 只要涉及到删除和添加操作的，链表都要从当前位置的前一个位置进行处理!

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

单链表
   单向链表只有一个方向, 节点只有一个后继指针next指向后面的节点。因为链表这种数据结构通常在物理内存上是不连续的。
   我们习惯性地把第一个节点叫做头节点, 链表通常有一个不保存任何值的dummyHead节点(也就是虚拟头节点), 通过虚拟头节点我们
   可以遍历整个链表, 尾节点通常指向null。
   (示例图片查看: linkedList.images.classify.linkedList_1.png)


循环链表
   循环链表其实是一种特殊的单链表, 和单链表不同的是循环链表的尾节点不是指向null, 而是指向链表的头节点。
   (示例图片查看: linkedList.images.classify.linkedList_2.png)


双向链表
   双向链表包含两个指针, 一个prev指向前一个节点, 一个next指向后一个节点。
   (示例图片查看: linkedList.images.classify.linkedList_3.png)


双向循环链表
   双向循环链表的最后一个节点的next指向head, 而head的prev指向最后一个节点, 构成一个环。
   (示例图片查看: linkedList.images.classify.linkedList_4.png)

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

数组 vs 链表
  1. 数组支持随机访问, 而链表不支持;
  2. 数组使用的是连续内存空间, 对CPU的缓存机制友好, 链表则相反;
  3. 数据的大小固定, 而链表则天然支持动态扩容, 如果声明的数组过小, 需要另外申请一个更大的内存空间存放数组元素,
     然后将原数组拷贝进去, 这个操作是比较耗时的;


总结:
  1. 链表是一种动态的数据结构;
  2. 在计算机中, 它使用的是非连续的内存空间来存储元素;
  3. 链表的优点是它不需要处理固定容量的问题, 可以充分利用计算机的内存空间, 实现灵活的内存动态管理;
  4. 链表的缺点就是它丧失了随机访问的能力;
  5. 常见链表可以分为4种, 分别是:
     5-1 单链表
     5-2 双向链表
     5-3 循环链表
     5-4 双向循环链表
  6. java 中的linkedList 它的底层数据结构就是双向链表;












