哈希表

散列表(Hash table, 也叫哈希表), 是根据关键码值(key value)而直接进行访问的数据结构。 也就是说, 它通过把关键码值映射到表中的一个位置来访问
记录, 以加快查找的速度。 这个映射函数叫做散列函数, 存放记录的'数组'叫做散列表。

给定表M， 存在函数f(key), 对任意给定的关键字值key, 代入函数后若能得到包含该关键字的记录在表中的地址, 则称表M为哈希(Hash)表, 函数f(key)为
哈希(Hash)函数;


基本概念
   1. 若关键字为k，则其值存放在f(k)的存储位置上。 由此, 无需比较便可直接取得所查记录。称这个对应关系f为散列函数,  按这个思想建立的表
      称为散列表;
   2. 对不同的关键字可能得到同一散列地址, 即k1 != k2, 而 f(k1) = f(k2), 这种现象称为冲突。具有相同函数值的关键字对该散列函数来说称作
      同义词。 综上所述, 根据散列函数 f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集(区间)上, 并以关键字在地址集中的"像"
      作为记录在表中的存储位置, 这种表便成为散列表, 这一映射过程称为散列造表或散列, 所得的存储位置称散列地址;
   3. 若对于关键字集合中的任一关键字, 经散列函数映像到地址集合中任何一个地址的概率是相等的, 则成此类散列函数为均匀散列函数(Uniform
      Hash function), 这就是使关键字经过过散列函数得到一个 "随机的地址", 从而减少冲突;


实际工作中需视不同的情况采用不同的哈希函数
   1. 计算哈希函数所需时间;
   2. 关键字的长度;
   3. 哈希表的大小;
   4. 关键字的分布情况;
   5. 记录的查找频率;

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

哈希表基础
   1. 从LeetCode-387题目开始;
   2. 问题背后就隐藏着哈希表这种思想;
   3. int[26] freq 就是一个哈希表!
      每一个字符都和一个索引项对应;
      a ——> 0
      b ——> 1
      c ——> 2
       ......
      z ——> 25
      O(1)的查找操作!       f(ch) = ch - 'a'
   4. 转换的过程就是 哈希函数, "键" 转换为 "索引";

   5. 键的类型由很多, 比如 身份证号、字符串、浮点数、日期

      所以, 很难保证每一个"键" 通过哈希函数的转换, 对应不同的"索引"，
      所以可能会产生哈希冲突, 在哈希表上的操作, 有很大一部分工作是在解决哈希冲突;

   6. 哈希表充分体现了算法设计领域的经典思想: 空间换时间;
      哈希表是时间和空间之间的平衡;
      哈希函数的设计是很重要的;
      "键" 通过哈希函数得到的 "索引" 分布越均匀越好;

   举例:
      身份证号 110108198512166666
      如果我们有 99999999999999999999 的空间, 我们可以用 O(1) 时间完成各项操作;
      如果我们有 1 的空间, 我们只能用 O(n) 时间完成各项操作(线性表);
      以上为两种极端情况


主要关注两方面内容:
   1. 哈希函数的设计;
   2. 产生哈希冲突如何解决;


哈希函数的设计
   1. "键"通过哈希函数得到的"索引"分布越均匀越好;
   2. 对于一些特殊领域, 有特殊领域的哈希函数设计方式甚至有专门的论文;
   3. 这个课程主要关注一般的哈希函数的设计原则;

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

所有类型的数据, 相应的hash函数的设计都转换成整型。


整型:
   1. 小范围正整数直接使用;
   2. 小范围负整数进行偏移;  (比如说: -100 ~ 100 ——> 0 ~ 200)

   3. 大整数(重点): 比如说身份证号 110108198512166666
      3-1 通常做法: 取模。
          (比如, 取后四位, 等同于 mod 10000)
          (取后六位, 等同于 mod 1000000)
          (会造成分布不均匀的情况, 因为日期只要 1~31，从32W开始的数据将无法使用， 所以需要具体问题具体分析。另外, 没有利用所有信息)

      3-2 进一步的解决方法: 模一个素数   (背后的数学理论超出课程范畴)
          模一个合数会出现不好的情况, 举例
          10 % 4 ——> 2
          20 % 4 ——> 0
          30 % 4 ——> 2
          40 % 4 ——> 0
          50 % 4 ——> 2

          模一个素数
          10 % 7 ——> 3
          20 % 7 ——> 6
          30 % 7 ——> 2
          40 % 7 ——> 4
          50 % 7 ——> 1

      3-3 取模参考网站: http://planetmath.org/goodhashtableprimes

======================================================================

浮点型:
   1. 在计算机中都是32为或者64位的二进制表示, 只不过计算机解析成了浮点数;
      解决方案: 转成整型处理

======================================================================

字符串
   1. 解决方案: 转成整型处理;
   2.
      2-1 166 = 1 * 10^2 + 6 * 10^1 + 10^0  (10进制方式)

      2-2 code = c * 26^3 + o * 26^2 + d * 26 + e * 26^0
          26进制表示法, 这样可以把字符串看成26进制大的整型;    (构造成26进制的方式)

      2-3 code = c * B^3 + o * B^2 + d * B^! + e * B^0
          hash(code) = (c * B^3 + o * B^2 + d * B^! + e * B^0 ) % M;        // M 代表取模的素数, 也代表数据的空间大小;

      2-4 进一步的转换
          hash(code) = ((((c * B)+ o) * B + d) * B + e) % M;                // 计算速度相对会快一点

      2-5 再进一步的转换
          hash(code) = ((((c % M) * B)+ o) % M * B + d) % M * B + e) % M;   // 保证不会溢出!

(这里涉及到了很多数学方面的概念)

======================================================================


复合类型
   比如学生类、日期类
     1. 解决方案: 依然可以转成整型处理。和处理字符串方式一样
        1-1 Date: year, month, day
            hash(date) = (((date.year%M)*B + date.month)%M * B + date.day) % M

======================================================================

总而言之:
   1. 基本都转成整型处理;
   2. 但并不是唯一的方法;


哈希函数的设计需要遵循的原则
   1. 一致性: 如果 a==b, 则 hash(a) == hash(b); (反过来不一定成立! 也就是哈希冲突的情况)
      (同样的hash值, 对应不同的键, 这就是所谓的哈希冲突)
   2. 高效性: 计算高效简便;
   3. 均匀性: 哈希值均匀分布;

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

Java中的hashCode


为什么 equals 和 hashCode 需要一起写?
产生 hash冲突, 也可以使用 equals 方法来区分!

面试的时候也会经常被问到


Java为什么要同时重写equals和hashcode
    一、内存地址
        1. equals默认是比较两个对象的内存地址是否相同
        2. hashCode根据对象的地址，生成int整数，即hash值，和地址一一对应

    二、重写
        1. 某些情况下，我们希望用对象的相同字段来比较是否相同，而不是地址
        2. 需要重写equals

    三、Set, Map
        这两个类是使用hashCode来比较定位的，如果不同时重写，会有问题

    四、如何重写
        lombok注解 @EqualsAndHashCode


https://www.cnblogs.com/liangjq/p/3753835.html

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

哈希冲突的处理 ———— 链地址法 (具体实现规则)
   1. 英文描述: Seperate Chaining, 最为常用;
   2. 哈希表本质就是一个数组;
   3. (hashCode(k1) & 0x7fffffff) % M, 相当于把符号给去掉了, 可以对应数组中的索引值;
      (按位与的计算方式去掌握!)

   4. 开一个M空间的数组, 每一个空间由于哈希冲突的存在, 存储的是一个表;
      4-1 查找表, 查找表可以使用链表, 也可以使用平衡树结构;
      4-2 在Java8之前, java的hash表实现, 每一个位置对应一个链表;
      4-3 从Java8开始, 当哈希冲突达到一定程度, 每一个位置从链表转成红黑树(TreeMap);

      4-4 HashMap 就是一个 TreeMap 数组;
          HashSet 就是一个 TreeSet 数组;

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

哈希表 链地址法
   1. 总共有 M个地址;
   2. 如果放入哈希表的元素为N;
   3. 如果每个地址是链表, 时间复杂度为: O(N/M)
   4. 如果每个地址是平衡树, 时间复杂度为: O(log(N/M))

   5. 但是现在还没有达到 O(1) 级别, 因为空间还跟 M 有关!  如果M取得比较好, 能够达到 O（1）级别
      (信息安全领域: 哈希碰撞攻击！)

   6. 和静态数组一样, 固定地址空间是不合理的, 需要 resize;
      平均每个地址承载的元素多过一定程度, 即扩容:  N/M >= upperTol  上界容忍度
      平均每个地址承载的元素少过一定程度, 即缩容:  N/M <  lowerTol  下界容忍度

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

哈希表的复杂度分析
   1. 回忆动态数组的均摊复杂度分析

   2. 对于哈希表来说, 元素数从 N 增加到 upperTo * N; 地址空间增倍, 平均复杂度 O(1)
      (每个操作 O(lowerTol) ~ O(upperTol))  ——> O(1)

   3. 缩容同理


更复杂的动态空间处理方法
   1. 扩容 M -> 2 * M,  因为 2*M不是素数, 可能导致分布不均匀;
   2. 解决方案
      2-1 使用 https://www.cnblogs.com/liangjq/p/3753835.html 中的素数;

哈希表
   1. 均摊复杂度为 O(1);
   2. 牺牲了什么?  顺序性
      AVL树、红黑树都保持了二分搜索树的性质, 这些数据结构保存了顺序性

   3. 思考: 一种算法比另一种算法好, 通常得到了什么，牺牲了什么，需要好好思考!
      更加深刻的认识!


集合、映射
   1. 有序集合，有序映射: java标准库中对应的就是 TreeSet、 TreeMap, 它的底层实现就是红黑树;
   2. 无序集合，无序映射: java标准库中对应的就是 HashSet、 HashMap, 它的底层实现就是哈希表;
   3. java标准库, 底层处理哈希冲突的方法也是链地址法;


我们的哈希表的bug
   1. HashTable<K, V>, K 不要求 Comparable;
   2. TreeMap<K, V>,   K 是要求 Comparable;            这里是矛盾的!

小练习: 实现一个初始地址是链表, 当哈希冲突达到一定程度变成红黑树;


其他解决哈希冲突的方法
   1. 开放地址法 ———— 线性探测法;
   2. 开放地址法 ———— 平方探测法;
   3. 开放地址法 ———— 二次哈希

   4. 再哈希法(Rehashing)
   5. Coalesced Hashing

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————






















