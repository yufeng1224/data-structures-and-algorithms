高级数据结构 ———— 堆和优先队列


队列:
   1. 普通队列: 先进先出; 后进后出
   2. 优先队列: 出队顺序和入队顺序无关; 和优先级相关; 它和普通队列的区别，在于出队这个操作上。 优先级高者先出队;
      最典型的应用: 操作系统的任务调度: 动态选择优先级最高的任务执行; (关键词: 动态)
   3. 优先队列可以使用不同的底层实现


PriorityQueue<E> 可以使用不同的底层实现 ———— 以下3种
                        入队              出队(拿出最大元素)
普通线性结构(数组)        O(1)             O(n)               可以建议实现试试看! 观察下性能
顺序线性结构(从大到大)     O(n)             O(1)
堆                     O(log(n))        O(log(n))          最差的情况下都是O(log(n))级别的复杂度

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

堆的基本结构
   1. 通常如果你在数据结构中见到了 log(n) 这种时间复杂度, 那么近乎一定和树这种结构有关;


堆的基本结构(重点) ———— 二叉堆的性质
   1. 二叉堆是一颗完全二叉树;
   2. 从左到右的顺序来存放节点;
   3. 完全二叉树: 把元素顺序排列成树的形状;
   4. 队中某个节点的值总是不大于其父节点的值; (最大堆, 相应的可以定义最小堆);
   5. 用数组存储二叉堆;
   6. 完全二叉树: 不一定是一个满的二叉树， 但它不满的部分一定是在整个树的右下侧;
   7. 堆只取出堆顶的元素;
      详见 extractMax() 函数


完全二叉树概念
   1. 特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。
      (需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树)
   2. 满二叉树: 一棵深度为k且有 2^k - 1 个结点的二叉树称为满二叉树;
   3. 完全二叉树: 不一定是一颗满的二叉树， 但它不满的部分一定是在整个树的右下侧;



二叉堆的两个性质
   1. 二叉堆是一颗完全二叉树;
   2. 队中某个节点的值总是不大于其父节点的值; (最大堆, 相应的可以定义最小堆);
   3. 通过数组进行标号, 从1开始, 层序遍历存放
      比如:  [-, 62, 41, 30, 28, 16, 22, 13, 19, 17, 15]

根据以上数组所得, 最大值父节点、 左子节点、 右子节点相互联系
   1. parent(i) = i/2
   2. left child (i) = 2 * i;
   3. right child(i) = 2 * i + 1;


为了消除数组为0位置元素为null的情况，做了改进
则最大值父节点、左子节点、右子节点相互联系如下
   1. parent(i) = (i - 1)/2
   2. left child (i) = 2 * i + 1;
   3. right child(i) = 2 * i + 2;



         62
      /      \
    41        30
  /   \     /    \
28     16  22     13        <———— 满二叉树



             62
          /      \
        41        30
      /   \     /    \
    28     16  22     13
   /  \    /
  19   17  15               <———— 完全二叉树(不满的那一层, 从左到右放置!)



堆由于是一颗完全二叉树，所以它永远不会退化成链表。 一定是 logn 级别的关系。


Heapify 和 Replace
replace: 取出最大元素后, 放入一个新元素。
   实现1: 可以先extractMax, 再add, 两次O(logn)的操作
         (一次 SiftDown, 一次 SiftUp, 所以是两次 O（logn）操作)
   实现2: 可以直接将堆顶元素替换以后SiftDown, 一次O(logn)的操作 ()

heapify: 将任意数组整理成堆的形状
   实现1: 将n个元素逐个插入到一个空堆中, 算法复杂度是O(nlogn)
   实现2: heapify 的过程, 算法复杂度为 O(n)

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

数据结构 ———— 堆
   1. 堆(heap) 是计算机科学中一类特殊的数据结构的统称;
   2. 堆总是满足下列特性:
      2-1 堆中某个结点的值总是不大于或者不小于其父结点的值;
      2-2 堆总是一颗完全二叉树;

   3. 根结点值最大的堆叫做最大堆; 根节点值最小的堆叫做最小堆;
   4. 堆是非线性数据结构, 不过可以看成一维数组;
   5. 堆的定义如下: n 个原始的序列{k1, k2, ki, ..., kn} 当且满足以下关系时, 称之为堆;
      (ki <= k2i 并且 ki <= k2i+1) 最小堆,  (ki >= k2i 并且 ki >= k2i+1) 最大堆;


二叉堆
   1. 二叉堆是一种特殊的堆;
   2. 二叉堆有两种: 最大堆和最小堆;
      2-1 最大堆: 父结点的值总是大于或者等于任何一个子结点的值;
      2-2 最小堆: 父结点的值总是小于或者等于任何一个子结点的值;

   3. 二叉堆一般用数组来表示, 如果根结点在数组中的位置是1, 则第n个位置的子结点分别在 2n 和 2n+1;
      因此, 第1个位置的子结点在2和3, 第2个位置的子结点在4和5, 因此类推。

   4. 如果存储数组的下标为0, 那么下标为i的结点的子结点是 2i+1 与 2i+2, 其父节点是 floor(i-1)/2。 floor 是向下取整;


————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

有一个经典的面试题: 如何定位最后一个非叶子节点, 获得索引?
    解答非常简单: 获取最后一个索引的父亲索引就可以了!
    (data.size() - 1) / 2


基于堆的优先队列 ———— 优先队列的经典问题: 在 1000 000 个元素中选出前100名?
延伸: 在N个元素中选出前M个元素。 这个问题的关键是 M 这个元素是远远小于N的。
     排序方式    时间复杂度:   NlogN
     优先队列    时间复杂度:   NlogM


解决方案: 使用优先队列，维护当前看到的前M个元素, 需要使用最小堆。
思路:
    1. 首先将N个元素中的前M个元素放入最小堆中
    2. 每次看到一个新的元素, 如果这个元素比当前这个队列中最小的那个元素大,
       则把优先队列中那个最小的元素扔出去， 换上新元素。
    3. 依然可以使用最大堆, 关键点是定义优先级，也就是实现 comparable接口  （大和小其实是相对的）
    4. 自己从底层实现最小堆;
    5. jdk 标准库中的 PriorityQueue, 内部设计的是一个最小堆;


和堆相关的更多话题和广义队列
    1. d叉堆 d-ary heap 层数相对会更少, 时间复杂度会变低，但是下沉操作会更复杂;
    2. 小练习: 实现 d 叉堆;
    3. 索引堆: 应用比较广泛，比较高级。 算法与数据结构会中讲到(另一门课程)! 二项堆， 斐波那契堆。


广义队列
   1. 普通队列
   2. 优先队列
   3. 栈，也可以理解成一个队列

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

总结:
   1. 二叉堆是一颗完全二叉树;
   2. 它的底层是通过数组实现的;
   3. 堆可以分为最大堆或者最小堆;
      3-1 如果是最大堆的话, 父节点的值总是大于子节点的值;
      3-2 如果是最小堆的话, 父节点的值总是小于子节点的值;
   4. 对于下标为i的结点, 它的子结点是 2i+1 与 2i+2, 它的父节点是 floor(i-1)/2;
   5. 在jdk中, 优先队列 PriorityQueue 的底层就应用到了堆这种数据结构;

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————



