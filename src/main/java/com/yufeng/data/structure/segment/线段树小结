树结构 ———— 线段树(区间树)(segment tree)


为什么要使用线段树?
   1. 对于有一类问题, 我们关心的是线段(或者区间);
   2. 最经典的线段树问题: 区间染色
      有一面墙, 长度为n， 每次选择一段儿墙进行染色。
      m次操作后, 我们可以看见多少种颜色?
      m次操作后, 我们可以在[i, j]区间内看见多少种颜色?
   3. 这里有2种操作
                            使用数组实现        使用线段树
      染色操作(更新区间)         O(n)             O(log(n))
      查询操作(查询区间)         O(n)             O(log(n))

   4. 另一类经典问题: 区间查询
   5. 问题举例: 查询一个区间[i,j]的最大值, 最小值, 或者区间数字和? (实质: 基于区间的统计查询)
      问题举例: 2017年注册用户中消费最高的用户? 消费最少的用户？ 学习时间最长的用户?
      问题举例: 某个太空区间中天体总量?

   6. 总结来说, 线段树所做的就是:
      对于给定区间
      6-1 更新: 更新区间中一个元素或者一个区间的值;
      6-2 查询: 查询一个区间[i, j]的最大值, 最小值, 或者区间数字和;


线段树特性:
   1. 不考虑向线段树中添加或删除元素, 大多数情况下区间本身是固定的;
   2. 底层通过数组来表示一个节点;
   3. 线段树不是完全二叉树;
   4. 线段树是平衡二叉树;
   5. 堆也是平衡二叉树;


如果区间有n个元素， 数组表示需要有多少个节点?
   1. 0层: 1;  1层: 2;  2层: 4; 3层: 8 ... h-1层: 2^(h-1);
   2. 对于满二叉树:
         h层, 一共有2^h - 1 个节点(大约是 2^h)
         最后一层(h-1层), 有 2^(h-1)个节点
         最后一层的节点数大致等于前面所有节点之和;

   3. 如果 n = 2^k， 只需要2n的空间;
      最坏情况, 如果 n = 2^k + 1, 则需要4n的空间;
   4. 做算法的关键依赖是用空间来换时间;

   5. 总结来说, 我们的线段树不考虑添加元素，即区间固定; 需要使用4n的静态空间即可;
      (最后一层，很有可能大量的位置都是空的, 存在浪费情况。 最坏情况下，有一半的空间都被浪费掉)

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

平衡二叉树(Balanced Binary Tree) 又被称为AVL树
   1. 平衡二叉树的性质: 它是一颗空树或它的左右两个子树的高度差的绝对值不超过1;
   2. 并且左右两个子树都是一颗平衡二叉树;
   3. 这个方案很好的解决了二叉查找树退化成链表的问题, 把插入、查找、删除的时间复杂度。最后情况和最坏情况都维持在 O(logN);
   4. 不过频繁旋转会使插入和删除牺牲掉 O(logN)左右的时间, 不过相对二叉查找树来说, 时间上稳定了很多;

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

























