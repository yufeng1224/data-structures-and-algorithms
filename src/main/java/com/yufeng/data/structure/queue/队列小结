线性数据结构 ———— 队列(queue)

队列
   1. 队列也是一种线性结构;
   2. 相比数组, 队列对应的操作是数组的子集;
   3. 只能从一端(队尾)添加元素, 只能从另一端(队首)取出元素;
   4. 队列是先进先出的数据结构 First In First Out(FIFO);


数组队列的实现: Queue<E>
   1. void enqueue(E)  	    O(1); 均摊复杂度;
   2. E  dequeue()		    O(n); 均摊复杂度;
   3. E  getFront()			O(1);
   4. int getSize()	        O(1);
   5. boolean isEmpty	    O(1);


小结:
   1. 队列是一种先进先出的线性数据结构，它可以分为数组队列和循环数组队列。 (后面还有链表队列)
   2. 数组队列出队时间复杂度为 O(n)， 循环队列为O(1), 循环队列的性能会远远好于数组队列。


循环队列规则
   1. front: 队首下标;
   2. tail:  队尾下标;
   3. front == tail,  队列为空;
   4. (tail + 1) % getCapacity() == front, 队列满了;
   5. 重点: tail 下标是空的，也就是说该位置上是没有元素的!
   6. 循环队列会有一个浪费的空间
   7. 要有循环的概念，类似于时钟, 或者丢手帕时围成的一个圈圈。
   8. 如果 front -- 有操作, 那么多余出来的那个空间也会进行插入操作
   9. front， tail 要有指针的概念， front 和 tail 指针的移动！


循环队列实现:
   1. 初始时, front 和 tail 都指向0, front == tail 队列为空;
   2. front == tail 队列为空, (tail + 1) % c == front 队列满了, capacity中, 浪费了一个空间, c = getCapacity() = data.length - 1
   3. 入队的话, tail ++, 出队的话 front ++。


循环队列的复杂度分析: LoopQueue<E>
   1. void enqueue(E)  	  O(1);     均摊复杂度;
   2. E  dequeue()		  O(1);     均摊复杂度;
   3. E  getFront()		  O(1);
   4. int getSize()	      O(1);
   5. boolean isEmpty	  O(1);

重点: 循环队列要好好看!  自定义实现的是 LoopQueue, jdk中的是 ArrayQueue


重点:
   1. 动态数组、栈、队列底层都是依托静态数组; 靠 resize 解决固定容量问题。
   2. 真正的动态数据结构;

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

总结
  1. 队列是一种先进先出的数据结构;
  2. 它只能从队首取出元素, 从队尾添加元素;
  3. 队列的底层可以通过数组来实现，叫做数组队列; 也可以通过链表实来现，叫做链式队列;
  4. 无论是数组队列还是链式队列, 我们都需要设置head和tail, 也就是双指针, 这样就可以保证出队和入队的时间复杂度都为O(1);
  5. 队列在生活中的应用场景就比较普遍
     5-1 比如说去医院或者银行， 都需要取号排队;

  6. 在计算机中,
     6-1 播放器上的播放列表也使用到了队列;
     6-2 线程池中没有空闲线程时, 会将任务放入队列中;
     6-3 队列经常应用于树结构的广度优先搜索;

————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

